diff --git a/numpy/_core/src/multiarray/multiarraymodule.c b/numpy/_core/src/multiarray/multiarraymodule.c
index 9816fb5bc0..f0f8547278 100644
--- a/numpy/_core/src/multiarray/multiarraymodule.c
+++ b/numpy/_core/src/multiarray/multiarraymodule.c
@@ -1448,6 +1448,23 @@ PyArray_EquivTypes(PyArray_Descr *type1, PyArray_Descr *type2)
         return 1;
     }
 
+    if (Py_TYPE(Py_TYPE(type1)) == &PyType_Type) {
+    /*
+        * 2021-12-17: This case is nonsense and should be removed eventually!
+        *
+        * boost::python has/had a bug effectively using EquivTypes with
+        * `type(arbitrary_obj)`.  That is clearly wrong as that cannot be a
+        * `PyArray_Descr *`.  We assume that `type(type(type(arbitrary_obj))`
+        * is always in practice `type` (this is the type of the metaclass),
+        * but for our descriptors, `type(type(descr))` is DTypeMeta.
+        *
+        * In that case, we just return False.  There is a possibility that
+        * this actually _worked_ effectively (returning 1 sometimes).
+        * We ignore that possibility for simplicity; it really is not our bug.
+        */
+    return 0;
+    }
+
     /*
      * Do not use PyArray_CanCastTypeTo because it supports legacy flexible
      * dtypes as input.
